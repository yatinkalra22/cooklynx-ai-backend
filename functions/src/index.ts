import {setGlobalOptions} from "firebase-functions";
import express, {
  ErrorRequestHandler,
  Request,
  Response,
  NextFunction,
} from "express";
import cors from "cors";
import helmet from "helmet";
import {ValidateError} from "tsoa";
import {randomUUID} from "crypto";
import * as logger from "firebase-functions/logger";
import {
  firebaseMulterMiddleware,
  createNoOpMulter,
} from "./middleware/firebase-multer";
import {
  initObservability,
  sentryErrorHandler,
  captureException,
} from "./observability";
import {corsOptions} from "./config/cors.config";
import {authLimiter, apiLimiter} from "./middleware/rate-limit.middleware";
import {
  validateRequiredEnvironment,
  validateOptionalEnvironment,
} from "./config/env-validation";
import {redactSensitiveData} from "./utils/validation.utils";

// Validate environment variables on startup
try {
  validateRequiredEnvironment();
  validateOptionalEnvironment();
} catch (error) {
  logger.error("Environment validation failed:", error);
  // In production, this will prevent the function from deploying
  throw error;
}

// Set global options for all functions
setGlobalOptions({
  maxInstances: 10,
  timeoutSeconds: 300, // 5 minutes for AI analysis
  memory: "1GiB", // More memory for image processing
});

// Create Express app
const app = express();

// Trust a single Cloud Run proxy hop for correct client IP handling
app.set("trust proxy", 1);

// Observability (Sentry)
initObservability(app);

// Security headers (helmet)
app.use(
  helmet({
    contentSecurityPolicy: {
      directives: {
        defaultSrc: ["'self'"],
        styleSrc: ["'self'", "'unsafe-inline'", "https://cdnjs.cloudflare.com"],
        scriptSrc: [
          "'self'",
          "'unsafe-inline'",
          "https://cdnjs.cloudflare.com",
        ],
        imgSrc: ["'self'", "data:", "https:"],
      },
    },
    hsts: {
      maxAge: 31536000, // 1 year
      includeSubDomains: true,
      preload: true,
    },
    frameguard: {action: "deny"},
    noSniff: true,
    xssFilter: true,
  })
);

// Additional security headers
app.use((req: Request, res: Response, next: NextFunction) => {
  res.setHeader("X-Content-Type-Options", "nosniff");
  res.setHeader("X-Frame-Options", "DENY");
  res.setHeader("X-XSS-Protection", "1; mode=block");
  res.setHeader("Referrer-Policy", "strict-origin-when-cross-origin");
  res.setHeader(
    "Permissions-Policy",
    "geolocation=(), microphone=(), camera=()"
  );
  next();
});

// CORS with whitelist
app.use(cors(corsOptions));

// Request logging + correlation ID
app.use((req: Request, res: Response, next: NextFunction) => {
  const requestId = req.header("x-request-id") || randomUUID();
  res.setHeader("x-request-id", requestId);
  res.locals.requestId = requestId;
  const start = Date.now();

  logger.info("request:start", {
    requestId,
    method: req.method,
    path: req.originalUrl,
    userAgent: req.get("user-agent"),
    ip: req.ip,
  });

  res.on("finish", () => {
    const durationMs = Date.now() - start;
    logger.info("request:end", {
      requestId,
      method: req.method,
      path: req.originalUrl,
      status: res.statusCode,
      durationMs,
    });

    // Usage analytics (log-based metrics)
    logger.info("api_usage", {
      requestId,
      method: req.method,
      path: req.originalUrl,
      status: res.statusCode,
      durationMs,
      userId: (req as {user?: {uid?: string}}).user?.uid,
    });
  });

  next();
});

// Parse multipart form data BEFORE body parsers
// This handles Firebase's rawBody for file uploads
app.use(firebaseMulterMiddleware());

app.use(express.json());
app.use(express.urlencoded({extended: true}));

// Rate limiting - apply before routes
// Strict rate limiting for auth endpoints
app.use("/v1/auth/login", authLimiter);
app.use("/v1/auth/signup", authLimiter);
app.use("/v1/auth/verification/resend", authLimiter);
// Moderate rate limiting for all API endpoints
app.use("/v1", apiLimiter);

// No-op multer for tsoa (files are already parsed by firebaseMulterMiddleware)
const noOpMulter = createNoOpMulter();

// Swagger UI - serve documentation
// Load swagger spec dynamically (generated by tsoa)
let swaggerDocument: object | null = null;
try {
  // eslint-disable-next-line @typescript-eslint/no-require-imports
  swaggerDocument = require("./generated/swagger.json");
} catch {
  logger.warn("Swagger spec not found. Run 'npm run swagger' to generate.");
}

if (swaggerDocument) {
  // OpenAPI JSON spec
  app.get("/docs.json", (_req, res) => res.json(swaggerDocument));
  app.get("/swagger.json", (_req, res) => res.json(swaggerDocument));
  app.get("/swagger", (_req, res) => {
    res.send(`<!DOCTYPE html>
<html>
<head>
  <title>CookLynx AI API</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/swagger-ui/5.18.2/swagger-ui.min.css">
</head>
<body>
  <div id="swagger-ui"></div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/swagger-ui/5.18.2/swagger-ui-bundle.min.js"></script>
  <script>
    SwaggerUIBundle({ url: './docs.json', dom_id: '#swagger-ui', persistAuthorization: true });
  </script>
</body>
</html>`);
  });
}

// Register tsoa generated routes with no-op multer
// eslint-disable-next-line @typescript-eslint/no-require-imports
const {RegisterRoutes} = require("./generated/routes");
RegisterRoutes(app, {multer: noOpMulter});

// tsoa validation error handler
app.use(
  (err: unknown, req: Request, res: Response, next: NextFunction): void => {
    if (err instanceof ValidateError) {
      logger.warn("validation:error", {
        requestId: res.locals.requestId,
        method: req.method,
        path: req.originalUrl,
        details: err.fields,
      });
      res.status(422).json({
        error: "Validation Failed",
        message: "Request validation failed",
        details: err.fields,
      });
      return;
    }
    next(err);
  }
);

// 404 handler
app.use((_req, res) => {
  res.status(404).json({error: "Not found"});
});

// Global error handler
const errorHandler: ErrorRequestHandler = (err, req, res, _next): void => {
  // Handle thrown error objects from controllers
  if (err && typeof err === "object" && "error" in err && "message" in err) {
    const status = res.statusCode !== 200 ? res.statusCode : 500;
    logger.error("request:error", {
      requestId: res.locals.requestId || req.get("x-request-id"),
      method: req.method,
      path: req.originalUrl,
      status,
      error: redactSensitiveData(err),
    });
    captureException(err, {
      requestId: res.locals.requestId || req.get("x-request-id"),
      method: req.method,
      path: req.originalUrl,
      status,
    });
    res.status(status).json(err);
    return;
  }

  logger.error("request:error", {
    requestId: res.locals.requestId || req.get("x-request-id"),
    method: req.method,
    path: req.originalUrl,
    status: 500,
    error: err instanceof Error ? err.message : "Unknown error",
  });
  captureException(err, {
    requestId: res.locals.requestId || req.get("x-request-id"),
    method: req.method,
    path: req.originalUrl,
    status: 500,
  });
  res.status(500).json({error: "Internal server error"});
};
app.use(errorHandler);

// Sentry error handler (after routes)
app.use(sentryErrorHandler());

export {app};

// Export Cloud Functions
export * from "./functions";
